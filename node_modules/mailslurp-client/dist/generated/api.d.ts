/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * OpenAPI spec version: beb7302db3b2458f4bba957b81a42c95e2289b11
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/// <reference path="../../src/generated/custom.d.ts" />
import { Configuration } from './configuration';
/**
 *
 * @export
 */
export declare const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}
/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}
/**
 *
 * @export
 * @class BaseAPI
 */
export declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export declare class RequiredError extends Error {
    field: string;
    name: 'RequiredError';
    constructor(field: string, msg?: string);
}
/**
 *
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    inboxId?: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof Alias
     */
    proxied?: boolean;
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    userId?: string;
}
/**
 * Meta data associated with an attachment. Attachments are stored as byte blobs so the meta data is stored separately.
 * @export
 * @interface AttachmentMetaData
 */
export interface AttachmentMetaData {
    /**
     * Size of attachment in bytes
     * @type {number}
     * @memberof AttachmentMetaData
     */
    contentLength?: number;
    /**
     * Content type of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    contentType?: string;
    /**
     * ID of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    id?: string;
    /**
     * Name of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    name?: string;
}
/**
 * Basic Authentication options for webhooks. Will be used is present when calling webhook endpoints.
 * @export
 * @interface BasicAuthOptions
 */
export interface BasicAuthOptions {
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    password: string;
}
/**
 * Options for bulk sending an email from multiple addresses. See regular `sendEmail` methods for more information.
 * @export
 * @interface BulkSendEmailOptions
 */
export interface BulkSendEmailOptions {
    /**
     * Inboxes to send the email from
     * @type {Array<string>}
     * @memberof BulkSendEmailOptions
     */
    inboxIds?: Array<string>;
    /**
     * Options for the email to be sent
     * @type {SendEmailOptions}
     * @memberof BulkSendEmailOptions
     */
    sendEmailOptions?: SendEmailOptions;
}
/**
 *
 * @export
 * @interface ContactDto
 */
export interface ContactDto {
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    company?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    emailAddresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    lastName?: string;
    /**
     *
     * @type {JsonNode}
     * @memberof ContactDto
     */
    metaData?: JsonNode;
    /**
     *
     * @type {boolean}
     * @memberof ContactDto
     */
    optOut?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    tags: Array<string>;
}
/**
 *
 * @export
 * @interface ContactProjection
 */
export interface ContactProjection {
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    company?: string;
    /**
     *
     * @type {Date}
     * @memberof ContactProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    lastName?: string;
    /**
     *
     * @type {boolean}
     * @memberof ContactProjection
     */
    optOut?: boolean;
}
/**
 * Create anonymous email alias options. Email aliases can be used to mask real email addresses behind an ID
 * @export
 * @interface CreateAnonymousAliasOptions
 */
export interface CreateAnonymousAliasOptions {
    /**
     * Email address to be hidden behind alias
     * @type {string}
     * @memberof CreateAnonymousAliasOptions
     */
    emailAddress?: string;
}
/**
 *
 * @export
 * @interface CreateContactOptions
 */
export interface CreateContactOptions {
    /**
     * Set of email addresses belonging to the contact
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    emailAddresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    firstName?: string;
    /**
     * Group IDs that contact belongs to
     * @type {string}
     * @memberof CreateContactOptions
     */
    groupId?: string;
    /**
     * User metadata key value pairs to save for this contact. Can be any values you like.
     * @type {JsonNode}
     * @memberof CreateContactOptions
     */
    metaData?: JsonNode;
    /**
     * Has the user explicitly or implicitly opted out of being contacted? If so MailSlurp will ignore them in all actions.
     * @type {boolean}
     * @memberof CreateContactOptions
     */
    optOut?: boolean;
    /**
     * Tags that can be used to search and group contacts
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    company?: string;
}
/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it.
 * @export
 * @interface CreateDomainOptions
 */
export interface CreateDomainOptions {
    /**
     * The top level domain you wish to use with MailSlurp
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domain?: string;
}
/**
 *
 * @export
 * @interface CreateGroupOptions
 */
export interface CreateGroupOptions {
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    description?: string;
}
/**
 * Create email alias options. Email aliases can be used to mask real email addresses behind an ID. You can also attach an inbox to an alias so that any email received by the inbox email address if forwarded to the alias email address.
 * @export
 * @interface CreateOwnedAliasOptions
 */
export interface CreateOwnedAliasOptions {
    /**
     * Email address to be hidden behind alias
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    emailAddress?: string;
    /**
     * Optional inbox ID to attach to alias. Emails received by this inbox will be forwarded to the alias email address
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    inboxId?: string;
    /**
     * Optional name for alias
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    name?: string;
    /**
     * Optional proxied flag. When proxied is true alias will forward the incoming emails to the aliased email address via a proxy inbox. A new proxy is created for every new email thread. By replying to the proxy you can correspond with using your email alias without revealing your real email address.
     * @type {boolean}
     * @memberof CreateOwnedAliasOptions
     */
    proxied?: boolean;
}
/**
 *
 * @export
 * @interface CreateTemplateOptions
 */
export interface CreateTemplateOptions {
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    content: string;
}
/**
 * Options for creating a webhook. Webhooks can be attached to inboxes and MailSlurp will POST a webhook payload to the URL specified whenever the inbox receives an email. Webhooks are great for processing many inbound emails.
 * @export
 * @interface CreateWebhookOptions
 */
export interface CreateWebhookOptions {
    /**
     * Optional basic authentication that MailSlurp should use when calling the URL. For instance if your URL is https://example.com then basic auth will call a URL like https://{username}@{password}:example.com
     * @type {BasicAuthOptions}
     * @memberof CreateWebhookOptions
     */
    basicAuth?: BasicAuthOptions;
    /**
     * Optional name for the webhook
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    name?: string;
    /**
     * Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received. The payload of the submitted JSON is described by https://api.mailslurp.com/schemas/webhook-payload
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    url?: string;
}
/**
 * Domain plus verification records and status
 * @export
 * @interface DomainDto
 */
export interface DomainDto {
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    id: string;
    /**
     *
     * @type {boolean}
     * @memberof DomainDto
     */
    isVerified: boolean;
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    userId: string;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    verificationToken: string;
}
/**
 * Preview object for domain entity
 * @export
 * @interface DomainPreview
 */
export interface DomainPreview {
    /**
     *
     * @type {Date}
     * @memberof DomainPreview
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    id: string;
}
/**
 * Email model (also referred to as EmailDto). Represents an email that was received by an inbox. If you want the original SMTP message see the `getRawEmail` endpoint.
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * Smart analysis of email content including spam ratings\"
     * @type {EmailAnalysis}
     * @memberof Email
     */
    analysis?: EmailAnalysis;
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof Email
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    bcc?: Array<string>;
    /**
     * The body of the email message
     * @type {string}
     * @memberof Email
     */
    body?: string;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    cc?: Array<string>;
    /**
     * Detected character set of the email body such as UTF-8
     * @type {string}
     * @memberof Email
     */
    charset?: string;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof Email
     */
    createdAt?: Date;
    /**
     * Who the email was sent from
     * @type {string}
     * @memberof Email
     */
    from?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * ID of the email
     * @type {string}
     * @memberof Email
     */
    id?: string;
    /**
     * ID of the inbox that received the email
     * @type {string}
     * @memberof Email
     */
    inboxId?: string;
    /**
     * Was HTML sent in the email body
     * @type {boolean}
     * @memberof Email
     */
    isHTML?: boolean;
    /**
     * Has the email been viewed ever
     * @type {boolean}
     * @memberof Email
     */
    read?: boolean;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof Email
     */
    subject?: string;
    /**
     * List of `To` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    to?: Array<string>;
    /**
     * When was the email last updated
     * @type {Date}
     * @memberof Email
     */
    updatedAt?: Date;
    /**
     * ID of user that email belongs
     * @type {string}
     * @memberof Email
     */
    userId?: string;
}
/**
 * Analysis result for email. Each verdict property is a string PASS|FAIL|GRAY or dynamic error message
 * @export
 * @interface EmailAnalysis
 */
export interface EmailAnalysis {
    /**
     * Verdict of DomainKeys Identified Mail analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dkimVerdict?: string;
    /**
     * Verdict of Domain-based Message Authentication Reporting and Conformance analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dmarcVerdict?: string;
    /**
     * Verdict of spam ranking analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spamVerdict?: string;
    /**
     * Verdict of Send Policy Framework record spoofing analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spfVerdict?: string;
    /**
     * Verdict of virus scan analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    virusVerdict?: string;
}
/**
 * Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID.
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    bcc?: Array<string>;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    cc?: Array<string>;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof EmailPreview
     */
    createdAt?: Date;
    /**
     * ID of the email
     * @type {string}
     * @memberof EmailPreview
     */
    id?: string;
    /**
     * Has the email been viewed ever
     * @type {boolean}
     * @memberof EmailPreview
     */
    read?: boolean;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     * List of `To` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    to?: Array<string>;
}
/**
 * A compact representation of a full email. Used in list endpoints to keep response sizes low. Body and attachments are not included. To get all fields of the email use the `getEmail` method with the email projection's ID. See `EmailDto` for documentation on projection properties.
 * @export
 * @interface EmailProjection
 */
export interface EmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    bcc?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof EmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailProjection
     */
    read?: boolean;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    to: Array<string>;
}
/**
 * Options for forwarding an email
 * @export
 * @interface ForwardEmailOptions
 */
export interface ForwardEmailOptions {
    /**
     * Optional bcc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional cc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    cc?: Array<string>;
    /**
     * Subject for forwarded email
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    subject?: string;
    /**
     * To recipients for forwarded email
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    to?: Array<string>;
}
/**
 *
 * @export
 * @interface GroupContactsDto
 */
export interface GroupContactsDto {
    /**
     *
     * @type {Array<ContactDto>}
     * @memberof GroupContactsDto
     */
    contacts: Array<ContactDto>;
    /**
     *
     * @type {GroupDto}
     * @memberof GroupContactsDto
     */
    group: GroupDto;
}
/**
 *
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     *
     * @type {Date}
     * @memberof GroupDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    name: string;
}
/**
 *
 * @export
 * @interface GroupProjection
 */
export interface GroupProjection {
    /**
     *
     * @type {Date}
     * @memberof GroupProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    name: string;
}
/**
 *
 * @export
 * @interface HTMLValidationResult
 */
export interface HTMLValidationResult {
    /**
     *
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    errors: Array<ValidationMessage>;
    /**
     *
     * @type {boolean}
     * @memberof HTMLValidationResult
     */
    isValid: boolean;
    /**
     *
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    warnings: Array<ValidationMessage>;
}
/**
 * Representation of an inbox with an email address. Emails can be sent to or from this email address.
 * @export
 * @interface Inbox
 */
export interface Inbox {
    /**
     * When was the inbox created
     * @type {Date}
     * @memberof Inbox
     */
    createdAt?: Date;
    /**
     * Optional description of an inbox for labelling purposes
     * @type {string}
     * @memberof Inbox
     */
    description?: string;
    /**
     * The inbox's email address. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints.
     * @type {string}
     * @memberof Inbox
     */
    emailAddress?: string;
    /**
     * When, if ever, will the inbox expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted.
     * @type {Date}
     * @memberof Inbox
     */
    expiresAt?: Date;
    /**
     * Is the inbox favourited
     * @type {boolean}
     * @memberof Inbox
     */
    favourite?: boolean;
    /**
     * ID of the inbox
     * @type {string}
     * @memberof Inbox
     */
    id?: string;
    /**
     * Optional name of the inbox. Displayed in the dashboard for easier search
     * @type {string}
     * @memberof Inbox
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with
     * @type {Array<string>}
     * @memberof Inbox
     */
    tags?: Array<string>;
    /**
     * ID of user that inbox belongs to
     * @type {string}
     * @memberof Inbox
     */
    userId?: string;
}
/**
 *
 * @export
 * @interface InboxProjection
 */
export interface InboxProjection {
    /**
     *
     * @type {Date}
     * @memberof InboxProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    emailAddress?: string;
    /**
     *
     * @type {Date}
     * @memberof InboxProjection
     */
    expiresAt?: Date;
    /**
     *
     * @type {boolean}
     * @memberof InboxProjection
     */
    favourite?: boolean;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    name?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof InboxProjection
     */
    tags?: Array<string>;
}
/**
 *
 * @export
 * @interface JsonNode
 */
export interface JsonNode {
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    array?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    bigDecimal?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    bigInteger?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    binary?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _boolean?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    containerNode?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _double?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _float?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    floatingPointNumber?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _int?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    integralNumber?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _long?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    missingNode?: boolean;
    /**
     *
     * @type {string}
     * @memberof JsonNode
     */
    nodeType?: JsonNode.NodeTypeEnum;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _null?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    number?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    object?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    pojo?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    _short?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    textual?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof JsonNode
     */
    valueNode?: boolean;
}
/**
 * @export
 * @namespace JsonNode
 */
export declare namespace JsonNode {
    /**
     * @export
     * @enum {string}
     */
    enum NodeTypeEnum {
        ARRAY,
        BINARY,
        BOOLEAN,
        MISSING,
        NULL,
        NUMBER,
        OBJECT,
        POJO,
        STRING
    }
}
/**
 * Options for matching emails in an inbox. Each match option object contains a `field`, `should` and `value` property. Together they form logical conditions such as `SUBJECT` should `CONTAIN` value.
 * @export
 * @interface MatchOption
 */
export interface MatchOption {
    /**
     * The email property to match on. One of SUBJECT, TO, BCC, CC or FROM
     * @type {string}
     * @memberof MatchOption
     */
    field?: MatchOption.FieldEnum;
    /**
     * What criteria to apply. CONTAIN or EQUAL. Note CONTAIN is recommended due to some SMTP servers adding new lines to fields and body content.
     * @type {string}
     * @memberof MatchOption
     */
    should?: MatchOption.ShouldEnum;
    /**
     * The value you wish to compare with the value of the field specified using the `should` value passed. For example `BODY` should `CONTAIN` a value passed.
     * @type {string}
     * @memberof MatchOption
     */
    value?: string;
}
/**
 * @export
 * @namespace MatchOption
 */
export declare namespace MatchOption {
    /**
     * @export
     * @enum {string}
     */
    enum FieldEnum {
        SUBJECT,
        TO,
        BCC,
        CC,
        FROM
    }
    /**
     * @export
     * @enum {string}
     */
    enum ShouldEnum {
        CONTAIN,
        EQUAL
    }
}
/**
 * Optional filter for matching emails based on fields. For instance filter results to only include emails whose `SUBJECT` value does `CONTAIN` given match value.
 * @export
 * @interface MatchOptions
 */
export interface MatchOptions {
    /**
     * 1 or more match options. Options are additive so if one does not match the email is excluded from results
     * @type {Array<MatchOption>}
     * @memberof MatchOptions
     */
    matches?: Array<MatchOption>;
}
/**
 *
 * @export
 * @interface PageAlias
 */
export interface PageAlias {
    /**
     *
     * @type {Array<Alias>}
     * @memberof PageAlias
     */
    content?: Array<Alias>;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageAlias
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageAlias
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageContactProjection
 */
export interface PageContactProjection {
    /**
     *
     * @type {Array<ContactProjection>}
     * @memberof PageContactProjection
     */
    content?: Array<ContactProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageContactProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageContactProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageEmailPreview
 */
export interface PageEmailPreview {
    /**
     *
     * @type {Array<EmailPreview>}
     * @memberof PageEmailPreview
     */
    content?: Array<EmailPreview>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailPreview
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailPreview
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageEmailProjection
 */
export interface PageEmailProjection {
    /**
     *
     * @type {Array<EmailProjection>}
     * @memberof PageEmailProjection
     */
    content?: Array<EmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageGroupProjection
 */
export interface PageGroupProjection {
    /**
     *
     * @type {Array<GroupProjection>}
     * @memberof PageGroupProjection
     */
    content?: Array<GroupProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageGroupProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageGroupProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageInboxProjection
 */
export interface PageInboxProjection {
    /**
     *
     * @type {Array<InboxProjection>}
     * @memberof PageInboxProjection
     */
    content?: Array<InboxProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageInboxProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageInboxProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageTemplateProjection
 */
export interface PageTemplateProjection {
    /**
     *
     * @type {Array<TemplateProjection>}
     * @memberof PageTemplateProjection
     */
    content?: Array<TemplateProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageTemplateProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageTemplateProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface PageWebhookProjection
 */
export interface PageWebhookProjection {
    /**
     *
     * @type {Array<WebhookProjection>}
     * @memberof PageWebhookProjection
     */
    content?: Array<WebhookProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageWebhookProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageWebhookProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalPages?: number;
}
/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     *
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 *
 * @export
 * @interface RawEmailJson
 */
export interface RawEmailJson {
    /**
     *
     * @type {string}
     * @memberof RawEmailJson
     */
    content: string;
}
/**
 * Options for sending an email message from an inbox. You must provide one of: `to`, `toGroup`, or `toContacts` to send an email. All other parameters are optional.
 * @export
 * @interface SendEmailOptions
 */
export interface SendEmailOptions {
    /**
     * Optional list of attachment IDs to send with this email. You must first upload each attachment separately in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Optional list of bcc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body.
     * @type {string}
     * @memberof SendEmailOptions
     */
    body?: string;
    /**
     * Optional list of cc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional charset
     * @type {string}
     * @memberof SendEmailOptions
     */
    charset?: string;
    /**
     * Optional from address. If not set the source inbox address will be used for this field. Beware of potential spam penalties when setting this field to an address not used by the inbox. For custom email addresses use a custom domain.
     * @type {string}
     * @memberof SendEmailOptions
     */
    from?: string;
    /**
     * Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients
     * @type {boolean}
     * @memberof SendEmailOptions
     */
    isHTML?: boolean;
    /**
     * Optional replyTo header
     * @type {string}
     * @memberof SendEmailOptions
     */
    replyTo?: string;
    /**
     * Optional strategy to use when sending the email
     * @type {string}
     * @memberof SendEmailOptions
     */
    sendStrategy?: SendEmailOptions.SendStrategyEnum;
    /**
     * Optional email subject line
     * @type {string}
     * @memberof SendEmailOptions
     */
    subject?: string;
    /**
     * Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
     * @type {string}
     * @memberof SendEmailOptions
     */
    template?: string;
    /**
     * Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
     * @type {any}
     * @memberof SendEmailOptions
     */
    templateVariables?: any;
    /**
     * List of destination email addresses. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating).
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    to?: Array<string>;
    /**
     * Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    toContacts?: Array<string>;
    /**
     * Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
     * @type {string}
     * @memberof SendEmailOptions
     */
    toGroup?: string;
}
/**
 * @export
 * @namespace SendEmailOptions
 */
export declare namespace SendEmailOptions {
    /**
     * @export
     * @enum {string}
     */
    enum SendStrategyEnum {
        SINGLEMESSAGE
    }
}
/**
 * Options for setting inbox favourite state
 * @export
 * @interface SetInboxFavouritedOptions
 */
export interface SetInboxFavouritedOptions {
    /**
     * Should the inbox be favourited?
     * @type {boolean}
     * @memberof SetInboxFavouritedOptions
     */
    state?: boolean;
}
/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}
/**
 *
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    content: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    name: string;
    /**
     *
     * @type {Array<TemplateVariable>}
     * @memberof TemplateDto
     */
    variables: Array<TemplateVariable>;
}
/**
 *
 * @export
 * @interface TemplateProjection
 */
export interface TemplateProjection {
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    name: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof TemplateProjection
     */
    variables: Array<string>;
}
/**
 *
 * @export
 * @interface TemplateVariable
 */
export interface TemplateVariable {
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    variableType: TemplateVariable.VariableTypeEnum;
}
/**
 * @export
 * @namespace TemplateVariable
 */
export declare namespace TemplateVariable {
    /**
     * @export
     * @enum {string}
     */
    enum VariableTypeEnum {
        STRING
    }
}
/**
 *
 * @export
 * @interface UnreadCount
 */
export interface UnreadCount {
    /**
     *
     * @type {number}
     * @memberof UnreadCount
     */
    count: number;
}
/**
 *
 * @export
 * @interface UpdateGroupContacts
 */
export interface UpdateGroupContacts {
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupContacts
     */
    contactIds: Array<string>;
}
/**
 * Options for updating inbox properties
 * @export
 * @interface UpdateInboxOptions
 */
export interface UpdateInboxOptions {
    /**
     * Optional description of an inbox for labelling purposes
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    description?: string;
    /**
     * When, if ever, will the inbox expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted.
     * @type {Date}
     * @memberof UpdateInboxOptions
     */
    expiresAt?: Date;
    /**
     * Is the inbox favourited
     * @type {boolean}
     * @memberof UpdateInboxOptions
     */
    favourite?: boolean;
    /**
     * Optional name of the inbox. Displayed in the dashboard for easier search
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with
     * @type {Array<string>}
     * @memberof UpdateInboxOptions
     */
    tags?: Array<string>;
}
/**
 * Options for uploading files for attachments. When sending emails with the API that require attachments first upload each attachment. Then use the returned attachment ID in your `SendEmailOptions` when sending an email. This way you can use attachments multiple times once they have been uploaded.
 * @export
 * @interface UploadAttachmentOptions
 */
export interface UploadAttachmentOptions {
    /**
     * Base64 encoded string of file contents
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    base64Contents?: string;
    /**
     * Optional contentType for file. For instance `application/pdf`
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    contentType?: string;
    /**
     * Optional filename to save upload with
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    filename?: string;
}
/**
 * Response object for email validation operation
 * @export
 * @interface ValidationDto
 */
export interface ValidationDto {
    /**
     * ID of the email validated
     * @type {string}
     * @memberof ValidationDto
     */
    emailId?: string;
    /**
     * Result of HTML validation
     * @type {HTMLValidationResult}
     * @memberof ValidationDto
     */
    html?: HTMLValidationResult;
}
/**
 *
 * @export
 * @interface ValidationMessage
 */
export interface ValidationMessage {
    /**
     *
     * @type {number}
     * @memberof ValidationMessage
     */
    lineNumber: number;
    /**
     *
     * @type {string}
     * @memberof ValidationMessage
     */
    message?: string;
}
/**
 * Conditions that a `waitForXEmails` endpoint operates on. The methods wait until given conditions are met or a timeout is reached. If the conditions are met without needing to wait the results will be returned immediately.
 * @export
 * @interface WaitForConditions
 */
export interface WaitForConditions {
    /**
     * Number of results that should match conditions. Either exactly or at least this amount based on the `countType`. If count condition is not met and the timeout has not been reached the `waitFor` method will retry the operation.
     * @type {number}
     * @memberof WaitForConditions
     */
    count?: number;
    /**
     * How should the found count be compared to the expected count.
     * @type {string}
     * @memberof WaitForConditions
     */
    countType?: WaitForConditions.CountTypeEnum;
    /**
     * ID of inbox to search within and apply conditions to. Essentially filtering the emails found to give a count.
     * @type {string}
     * @memberof WaitForConditions
     */
    inboxId?: string;
    /**
     * Conditions that should be matched for an email to qualify for results. Each condition will be applied in order to each email within an inbox to filter a result list of matching emails you are waiting for.
     * @type {Array<MatchOption>}
     * @memberof WaitForConditions
     */
    matches?: Array<MatchOption>;
    /**
     * Direction to sort matching emails by created time
     * @type {string}
     * @memberof WaitForConditions
     */
    sortDirection?: WaitForConditions.SortDirectionEnum;
    /**
     * Max time in milliseconds to retry the `waitFor` operation until conditions are met.
     * @type {number}
     * @memberof WaitForConditions
     */
    timeout?: number;
    /**
     * Apply conditions only to **unread** emails. All emails begin with `read=false`. An email is marked `read=true` when an `EmailDto` representation of it has been returned to the user at least once. For example you have called `getEmail` or `waitForLatestEmail` etc., or you have viewed the email in the dashboard.
     * @type {boolean}
     * @memberof WaitForConditions
     */
    unreadOnly?: boolean;
}
/**
 * @export
 * @namespace WaitForConditions
 */
export declare namespace WaitForConditions {
    /**
     * @export
     * @enum {string}
     */
    enum CountTypeEnum {
        EXACTLY,
        ATLEAST
    }
    /**
     * @export
     * @enum {string}
     */
    enum SortDirectionEnum {
        ASC,
        DESC
    }
}
/**
 * Representation of a webhook for an inbox. The URL specified will be using by MailSlurp whenever an email is received by the attached inbox.
 * @export
 * @interface WebhookDto
 */
export interface WebhookDto {
    /**
     * Does webhook expect basic authentication? If true it means you created this webhook with a username and password. MailSlurp will use these in the URL to authenticate itself.
     * @type {boolean}
     * @memberof WebhookDto
     */
    basicAuth?: boolean;
    /**
     * When the webhook was created
     * @type {Date}
     * @memberof WebhookDto
     */
    createdAt?: Date;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof WebhookDto
     */
    id?: string;
    /**
     * The inbox that the Webhook will be triggered by
     * @type {string}
     * @memberof WebhookDto
     */
    inboxId?: string;
    /**
     * HTTP method that your server endpoint must listen for
     * @type {string}
     * @memberof WebhookDto
     */
    method?: WebhookDto.MethodEnum;
    /**
     * Name of the webhook
     * @type {string}
     * @memberof WebhookDto
     */
    name?: string;
    /**
     * JSON Schema for the payload that will be sent to your URL via the HTTP method described.
     * @type {string}
     * @memberof WebhookDto
     */
    payloadJsonSchema?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookDto
     */
    updatedAt: Date;
    /**
     * URL of your server that the webhook will be sent to. The schema of the JSON that is sent is described by the payloadJsonSchema.
     * @type {string}
     * @memberof WebhookDto
     */
    url?: string;
}
/**
 * @export
 * @namespace WebhookDto
 */
export declare namespace WebhookDto {
    /**
     * @export
     * @enum {string}
     */
    enum MethodEnum {
        GET,
        HEAD,
        POST,
        PUT,
        PATCH,
        DELETE,
        OPTIONS,
        TRACE
    }
}
/**
 * Representation of a webhook
 * @export
 * @interface WebhookProjection
 */
export interface WebhookProjection {
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    url: string;
}
/**
 *
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof WebhookTestRequest
     */
    headers: {
        [key: string]: string;
    };
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    method: WebhookTestRequest.MethodEnum;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    payload?: string;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    url: string;
}
/**
 * @export
 * @namespace WebhookTestRequest
 */
export declare namespace WebhookTestRequest {
    /**
     * @export
     * @enum {string}
     */
    enum MethodEnum {
        GET,
        HEAD,
        POST,
        PUT,
        PATCH,
        DELETE,
        OPTIONS,
        TRACE
    }
}
/**
 *
 * @export
 * @interface WebhookTestResponse
 */
export interface WebhookTestResponse {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResponse
     */
    message?: string;
    /**
     *
     * @type {number}
     * @memberof WebhookTestResponse
     */
    statusCode?: number;
}
/**
 * Results of testing a webhook
 * @export
 * @interface WebhookTestResult
 */
export interface WebhookTestResult {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResult
     */
    message?: string;
    /**
     *
     * @type {WebhookTestRequest}
     * @memberof WebhookTestResult
     */
    request: WebhookTestRequest;
    /**
     *
     * @type {WebhookTestResponse}
     * @memberof WebhookTestResult
     */
    response: WebhookTestResponse;
}
/**
 * AliasControllerApi - fetch parameter creator
 * @export
 */
export declare const AliasControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAnonymousAlias(createAnonymousAliasOptions: CreateAnonymousAliasOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(aliasId: string, options?: any): FetchArgs;
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(aliasId: string, options?: any): FetchArgs;
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAliases(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(aliasId: string, createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): FetchArgs;
};
/**
 * AliasControllerApi - functional programming interface
 * @export
 */
export declare const AliasControllerApiFp: (configuration?: Configuration) => {
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAnonymousAlias(createAnonymousAliasOptions: CreateAnonymousAliasOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alias>;
    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(aliasId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(aliasId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alias>;
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAliases(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageAlias>;
    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(aliasId: string, createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
};
/**
 * AliasControllerApi - factory interface
 * @export
 */
export declare const AliasControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAlias(createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): Promise<Response>;
    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAnonymousAlias(createAnonymousAliasOptions: CreateAnonymousAliasOptions, options?: any): Promise<Alias>;
    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAlias(aliasId: string, options?: any): Promise<Response>;
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAlias(aliasId: string, options?: any): Promise<Alias>;
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAliases(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageAlias>;
    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAlias(aliasId: string, createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): Promise<Response>;
};
/**
 * AliasControllerApi - object-oriented interface
 * @export
 * @class AliasControllerApi
 * @extends {BaseAPI}
 */
export declare class AliasControllerApi extends BaseAPI {
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    createAlias(createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): Promise<Response>;
    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    createAnonymousAlias(createAnonymousAliasOptions: CreateAnonymousAliasOptions, options?: any): Promise<Alias>;
    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    deleteAlias(aliasId: string, options?: any): Promise<Response>;
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    getAlias(aliasId: string, options?: any): Promise<Alias>;
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    getAliases(page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageAlias>;
    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    updateAlias(aliasId: string, createOwnedAliasOptions: CreateOwnedAliasOptions, options?: any): Promise<Response>;
}
/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
export declare const AttachmentControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadOptions: UploadAttachmentOptions, options?: any): FetchArgs;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [contentTypeHeader] contentTypeHeader
     * @param {string} [filename] filename
     * @param {string} [xFilename] x-filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, contentTypeHeader?: string, filename?: string, xFilename?: string, options?: any): FetchArgs;
};
/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
export declare const AttachmentControllerApiFp: (configuration?: Configuration) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadOptions: UploadAttachmentOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [contentTypeHeader] contentTypeHeader
     * @param {string} [filename] filename
     * @param {string} [xFilename] x-filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, contentTypeHeader?: string, filename?: string, xFilename?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string[]>;
};
/**
 * AttachmentControllerApi - factory interface
 * @export
 */
export declare const AttachmentControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(uploadOptions: UploadAttachmentOptions, options?: any): Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [contentTypeHeader] contentTypeHeader
     * @param {string} [filename] filename
     * @param {string} [xFilename] x-filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMultipartForm(file: any, contentType?: string, contentTypeHeader?: string, filename?: string, xFilename?: string, options?: any): Promise<string[]>;
};
/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
export declare class AttachmentControllerApi extends BaseAPI {
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    uploadAttachment(uploadOptions: UploadAttachmentOptions, options?: any): Promise<string[]>;
    /**
     * When sending emails with attachments first upload each attachment with this endpoint. Record the returned attachment IDs. Then use these attachment IDs in the SendEmailOptions when sending an email. This means that attachments can easily be reused.
     * @summary Upload an attachment for sending using Multipart Form
     * @param {any} file file
     * @param {string} [contentType] contentType
     * @param {string} [contentTypeHeader] contentTypeHeader
     * @param {string} [filename] filename
     * @param {string} [xFilename] x-filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    uploadMultipartForm(file: any, contentType?: string, contentTypeHeader?: string, filename?: string, xFilename?: string, options?: any): Promise<string[]>;
}
/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
export declare const BulkActionsControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): FetchArgs;
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(ids: string[], options?: any): FetchArgs;
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): FetchArgs;
};
/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
export declare const BulkActionsControllerApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox[]>;
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(ids: string[], options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
};
/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
export declare const BulkActionsControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateInboxes(count: number, options?: any): Promise<Inbox[]>;
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteInboxes(ids: string[], options?: any): Promise<Response>;
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): Promise<Response>;
};
/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
export declare class BulkActionsControllerApi extends BaseAPI {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkCreateInboxes(count: number, options?: any): Promise<Inbox[]>;
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkDeleteInboxes(ids: Array<string>, options?: any): Promise<Response>;
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    bulkSendEmails(bulkSendEmailOptions: BulkSendEmailOptions, options?: any): Promise<Response>;
}
/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
export declare const CommonActionsControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): FetchArgs;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): FetchArgs;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): FetchArgs;
};
/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
export declare const CommonActionsControllerApiFp: (configuration?: Configuration) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
};
/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
export declare const CommonActionsControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewEmailAddress(options?: any): Promise<Inbox>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emptyInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
};
/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
export declare class CommonActionsControllerApi extends BaseAPI {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    createNewEmailAddress(options?: any): Promise<Inbox>;
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    emptyInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * To specify an email address first create an inbox and use that with the other send email methods
     * @summary Send an email from a random email address
     * @param {SendEmailOptions} sendEmailOptions sendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    sendEmailSimple(sendEmailOptions: SendEmailOptions, options?: any): Promise<Response>;
}
/**
 * ContactControllerApi - fetch parameter creator
 * @export
 */
export declare const ContactControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContact(createContactOptions: CreateContactOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContact(contactId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContacts(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContact(contactId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContacts(options?: any): FetchArgs;
};
/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export declare const ContactControllerApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContact(createContactOptions: CreateContactOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto>;
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContact(contactId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContacts(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageContactProjection>;
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContact(contactId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto>;
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContacts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactProjection[]>;
};
/**
 * ContactControllerApi - factory interface
 * @export
 */
export declare const ContactControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContact(createContactOptions: CreateContactOptions, options?: any): Promise<ContactDto>;
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContact(contactId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllContacts(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageContactProjection>;
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContact(contactId: string, options?: any): Promise<ContactDto>;
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContacts(options?: any): Promise<ContactProjection[]>;
};
/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export declare class ContactControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    createContact(createContactOptions: CreateContactOptions, options?: any): Promise<ContactDto>;
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    deleteContact(contactId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    getAllContacts(page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageContactProjection>;
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    getContact(contactId: string, options?: any): Promise<ContactDto>;
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    getContacts(options?: any): Promise<ContactProjection[]>;
}
/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
export declare const DomainControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(domainOptions: CreateDomainOptions, options?: any): FetchArgs;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): FetchArgs;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): FetchArgs;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): FetchArgs;
};
/**
 * DomainControllerApi - functional programming interface
 * @export
 */
export declare const DomainControllerApiFp: (configuration?: Configuration) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(domainOptions: CreateDomainOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DomainPreview[]>;
};
/**
 * DomainControllerApi - factory interface
 * @export
 */
export declare const DomainControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDomain(domainOptions: CreateDomainOptions, options?: any): Promise<DomainDto>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDomain(id: string, options?: any): Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomain(id: string, options?: any): Promise<DomainDto>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDomains(options?: any): Promise<DomainPreview[]>;
};
/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
export declare class DomainControllerApi extends BaseAPI {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    createDomain(domainOptions: CreateDomainOptions, options?: any): Promise<DomainDto>;
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    deleteDomain(id: string, options?: any): Promise<Response>;
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    getDomain(id: string, options?: any): Promise<DomainDto>;
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    getDomains(options?: any): Promise<DomainPreview[]>;
}
/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
export declare const EmailControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllEmails(options?: any): FetchArgs;
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): FetchArgs;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): FetchArgs;
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): FetchArgs;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): FetchArgs;
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachments(emailId: string, options?: any): FetchArgs;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, decode?: boolean, options?: any): FetchArgs;
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailHTML(emailId: string, decode?: boolean, options?: any): FetchArgs;
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(inboxId?: string[], page?: number, size?: number, sort?: "ASC" | "DESC", unreadOnly?: boolean, options?: any): FetchArgs;
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): FetchArgs;
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailJson(emailId: string, options?: any): FetchArgs;
    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUnreadEmailCount(options?: any): FetchArgs;
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateEmail(emailId: string, options?: any): FetchArgs;
};
/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export declare const EmailControllerApiFp: (configuration?: Configuration) => {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllEmails(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentMetaData>;
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachments(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentMetaData[]>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, decode?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailHTML(emailId: string, decode?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(inboxId?: string[], page?: number, size?: number, sort?: "ASC" | "DESC", unreadOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailJson(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RawEmailJson>;
    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUnreadEmailCount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UnreadCount>;
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateEmail(emailId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ValidationDto>;
};
/**
 * EmailControllerApi - factory interface
 * @export
 */
export declare const EmailControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllEmails(options?: any): Promise<Response>;
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmail(emailId: string, options?: any): Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): Promise<string>;
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): Promise<AttachmentMetaData>;
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachments(emailId: string, options?: any): Promise<AttachmentMetaData[]>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmail(emailId: string, decode?: boolean, options?: any): Promise<Email>;
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailHTML(emailId: string, decode?: boolean, options?: any): Promise<string>;
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailsPaginated(inboxId?: string[], page?: number, size?: number, sort?: "ASC" | "DESC", unreadOnly?: boolean, options?: any): Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailContents(emailId: string, options?: any): Promise<string>;
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRawEmailJson(emailId: string, options?: any): Promise<RawEmailJson>;
    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUnreadEmailCount(options?: any): Promise<UnreadCount>;
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateEmail(emailId: string, options?: any): Promise<ValidationDto>;
};
/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export declare class EmailControllerApi extends BaseAPI {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    deleteAllEmails(options?: any): Promise<Response>;
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    deleteEmail(emailId: string, options?: any): Promise<Response>;
    /**
     * Returns the specified attachment for a given email as a byte stream (file download). You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    downloadAttachment(attachmentId: string, emailId: string, apiKey?: string, options?: any): Promise<string>;
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId emailId
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    forwardEmail(emailId: string, forwardEmailOptions: ForwardEmailOptions, options?: any): Promise<Response>;
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId attachmentId
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getAttachmentMetaData(attachmentId: string, emailId: string, options?: any): Promise<AttachmentMetaData>;
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getAttachments(emailId: string, options?: any): Promise<AttachmentMetaData[]>;
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getEmail(emailId: string, decode?: boolean, options?: any): Promise<Email>;
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getEmailHTML(emailId: string, decode?: boolean, options?: any): Promise<string>;
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getEmailsPaginated(inboxId?: Array<string>, page?: number, size?: number, sort?: 'ASC' | 'DESC', unreadOnly?: boolean, options?: any): Promise<PageEmailProjection>;
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getRawEmailContents(emailId: string, options?: any): Promise<string>;
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getRawEmailJson(emailId: string, options?: any): Promise<RawEmailJson>;
    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    getUnreadEmailCount(options?: any): Promise<UnreadCount>;
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId emailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    validateEmail(emailId: string, options?: any): Promise<ValidationDto>;
}
/**
 * FormControllerApi - fetch parameter creator
 * @export
 */
export declare const FormControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitForm(emailAddress?: string, redirectTo?: string, spamCheck?: string, subject?: string, successMessage?: string, to?: string, toAlias?: string, otherParameters?: string, options?: any): FetchArgs;
};
/**
 * FormControllerApi - functional programming interface
 * @export
 */
export declare const FormControllerApiFp: (configuration?: Configuration) => {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitForm(emailAddress?: string, redirectTo?: string, spamCheck?: string, subject?: string, successMessage?: string, to?: string, toAlias?: string, otherParameters?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string>;
};
/**
 * FormControllerApi - factory interface
 * @export
 */
export declare const FormControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submitForm(emailAddress?: string, redirectTo?: string, spamCheck?: string, subject?: string, successMessage?: string, to?: string, toAlias?: string, otherParameters?: string, options?: any): Promise<string>;
};
/**
 * FormControllerApi - object-oriented interface
 * @export
 * @class FormControllerApi
 * @extends {BaseAPI}
 */
export declare class FormControllerApi extends BaseAPI {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormControllerApi
     */
    submitForm(emailAddress?: string, redirectTo?: string, spamCheck?: string, subject?: string, successMessage?: string, to?: string, toAlias?: string, otherParameters?: string, options?: any): Promise<string>;
}
/**
 * GroupControllerApi - fetch parameter creator
 * @export
 */
export declare const GroupControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addContactsToGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): FetchArgs;
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(createGroupOptions: CreateGroupOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGroups(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupWithContacts(groupId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(options?: any): FetchArgs;
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeContactsFromGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): FetchArgs;
};
/**
 * GroupControllerApi - functional programming interface
 * @export
 */
export declare const GroupControllerApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addContactsToGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto>;
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(createGroupOptions: CreateGroupOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto>;
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGroups(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageGroupProjection>;
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto>;
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupWithContacts(groupId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto>;
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupProjection[]>;
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeContactsFromGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto>;
};
/**
 * GroupControllerApi - factory interface
 * @export
 */
export declare const GroupControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addContactsToGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): Promise<GroupContactsDto>;
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(createGroupOptions: CreateGroupOptions, options?: any): Promise<GroupDto>;
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllGroups(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageGroupProjection>;
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, options?: any): Promise<GroupDto>;
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupWithContacts(groupId: string, options?: any): Promise<GroupContactsDto>;
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroups(options?: any): Promise<GroupProjection[]>;
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeContactsFromGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): Promise<GroupContactsDto>;
};
/**
 * GroupControllerApi - object-oriented interface
 * @export
 * @class GroupControllerApi
 * @extends {BaseAPI}
 */
export declare class GroupControllerApi extends BaseAPI {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    addContactsToGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): Promise<GroupContactsDto>;
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    createGroup(createGroupOptions: CreateGroupOptions, options?: any): Promise<GroupDto>;
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    deleteGroup(groupId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    getAllGroups(page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageGroupProjection>;
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    getGroup(groupId: string, options?: any): Promise<GroupDto>;
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    getGroupWithContacts(groupId: string, options?: any): Promise<GroupContactsDto>;
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    getGroups(options?: any): Promise<GroupProjection[]>;
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    removeContactsFromGroup(groupId: string, updateGroupContactsOption: UpdateGroupContacts, options?: any): Promise<GroupContactsDto>;
}
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export declare const InboxControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(description?: string, emailAddress?: string, expiresAt?: Date, favourite?: boolean, name?: string, tags?: string[], options?: any): FetchArgs;
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllInboxes(options?: any): FetchArgs;
    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): FetchArgs;
    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(favourite?: boolean, page?: number, search?: string, size?: number, sort?: "ASC" | "DESC", tag?: string, options?: any): FetchArgs;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): FetchArgs;
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxEmailsPaginated(inboxId: string, page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxTags(options?: any): FetchArgs;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): FetchArgs;
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions?: SendEmailOptions, options?: any): FetchArgs;
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInboxFavourited(inboxId: string, setInboxFavouritedOptions: SetInboxFavouritedOptions, options?: any): FetchArgs;
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInbox(inboxId: string, updateInboxOptions: UpdateInboxOptions, options?: any): FetchArgs;
};
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export declare const InboxControllerApiFp: (configuration?: Configuration) => {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(description?: string, emailAddress?: string, expiresAt?: Date, favourite?: boolean, name?: string, tags?: string[], options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllInboxes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(favourite?: boolean, page?: number, search?: string, size?: number, sort?: "ASC" | "DESC", tag?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxEmailsPaginated(inboxId: string, page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailPreview>;
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxTags(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string[]>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox[]>;
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions?: SendEmailOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInboxFavourited(inboxId: string, setInboxFavouritedOptions: SetInboxFavouritedOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInbox(inboxId: string, updateInboxOptions: UpdateInboxOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox>;
};
/**
 * InboxControllerApi - factory interface
 * @export
 */
export declare const InboxControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInbox(description?: string, emailAddress?: string, expiresAt?: Date, favourite?: boolean, name?: string, tags?: string[], options?: any): Promise<Inbox>;
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllInboxes(options?: any): Promise<Response>;
    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInboxes(favourite?: boolean, page?: number, search?: string, size?: number, sort?: "ASC" | "DESC", tag?: string, options?: any): Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, sort?: "ASC" | "DESC", options?: any): Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInbox(inboxId: string, options?: any): Promise<Inbox>;
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxEmailsPaginated(inboxId: string, page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageEmailPreview>;
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxTags(options?: any): Promise<string[]>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboxes(options?: any): Promise<Inbox[]>;
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmail(inboxId: string, sendEmailOptions?: SendEmailOptions, options?: any): Promise<Response>;
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInboxFavourited(inboxId: string, setInboxFavouritedOptions: SetInboxFavouritedOptions, options?: any): Promise<Inbox>;
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInbox(inboxId: string, updateInboxOptions: UpdateInboxOptions, options?: any): Promise<Inbox>;
};
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export declare class InboxControllerApi extends BaseAPI {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    createInbox(description?: string, emailAddress?: string, expiresAt?: Date, favourite?: boolean, name?: string, tags?: Array<string>, options?: any): Promise<Inbox>;
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    deleteAllInboxes(options?: any): Promise<Response>;
    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    deleteInbox(inboxId: string, options?: any): Promise<Response>;
    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getAllInboxes(favourite?: boolean, page?: number, search?: string, size?: number, sort?: 'ASC' | 'DESC', tag?: string, options?: any): Promise<PageInboxProjection>;
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getEmails(inboxId: string, limit?: number, minCount?: number, retryTimeout?: number, since?: Date, sort?: 'ASC' | 'DESC', options?: any): Promise<EmailPreview[]>;
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInbox(inboxId: string, options?: any): Promise<Inbox>;
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInboxEmailsPaginated(inboxId: string, page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageEmailPreview>;
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInboxTags(options?: any): Promise<string[]>;
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    getInboxes(options?: any): Promise<Inbox[]>;
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    sendEmail(inboxId: string, sendEmailOptions?: SendEmailOptions, options?: any): Promise<Response>;
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    setInboxFavourited(inboxId: string, setInboxFavouritedOptions: SetInboxFavouritedOptions, options?: any): Promise<Inbox>;
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    updateInbox(inboxId: string, updateInboxOptions: UpdateInboxOptions, options?: any): Promise<Inbox>;
}
/**
 * TemplateControllerApi - fetch parameter creator
 * @export
 */
export declare const TemplateControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemplate(createTemplateOptions: CreateTemplateOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTemplate(templateId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplate(templateId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplates(options?: any): FetchArgs;
};
/**
 * TemplateControllerApi - functional programming interface
 * @export
 */
export declare const TemplateControllerApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemplate(createTemplateOptions: CreateTemplateOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto>;
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTemplate(templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageTemplateProjection>;
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplate(templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto>;
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplates(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateProjection[]>;
};
/**
 * TemplateControllerApi - factory interface
 * @export
 */
export declare const TemplateControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTemplate(createTemplateOptions: CreateTemplateOptions, options?: any): Promise<TemplateDto>;
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTemplate(templateId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTemplates(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageTemplateProjection>;
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplate(templateId: string, options?: any): Promise<TemplateDto>;
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTemplates(options?: any): Promise<TemplateProjection[]>;
};
/**
 * TemplateControllerApi - object-oriented interface
 * @export
 * @class TemplateControllerApi
 * @extends {BaseAPI}
 */
export declare class TemplateControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    createTemplate(createTemplateOptions: CreateTemplateOptions, options?: any): Promise<TemplateDto>;
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    deleteTemplate(templateId: string, options?: any): Promise<Response>;
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    getAllTemplates(page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageTemplateProjection>;
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    getTemplate(templateId: string, options?: any): Promise<TemplateDto>;
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    getTemplates(options?: any): Promise<TemplateProjection[]>;
}
/**
 * WaitForControllerApi - fetch parameter creator
 * @export
 */
export declare const WaitForControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitFor(waitForConditions?: WaitForConditions, options?: any): FetchArgs;
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): FetchArgs;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): FetchArgs;
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): FetchArgs;
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, unreadOnly?: boolean, options?: any): FetchArgs;
};
/**
 * WaitForControllerApi - functional programming interface
 * @export
 */
export declare const WaitForControllerApiFp: (configuration?: Configuration) => {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitFor(waitForConditions?: WaitForConditions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailPreview[]>;
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, unreadOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Email>;
};
/**
 * WaitForControllerApi - factory interface
 * @export
 */
export declare const WaitForControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitFor(waitForConditions?: WaitForConditions, options?: any): Promise<EmailPreview[]>;
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<Email>;
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<EmailPreview[]>;
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, unreadOnly?: boolean, options?: any): Promise<Email>;
};
/**
 * WaitForControllerApi - object-oriented interface
 * @export
 * @class WaitForControllerApi
 * @extends {BaseAPI}
 */
export declare class WaitForControllerApi extends BaseAPI {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    waitFor(waitForConditions?: WaitForConditions, options?: any): Promise<EmailPreview[]>;
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    waitForEmailCount(count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<EmailPreview[]>;
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox see the other receive methods such as waitForNthEmail or waitForEmailCount.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    waitForLatestEmail(inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<Email>;
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    waitForMatchingEmail(matchOptions: MatchOptions, count?: number, inboxId?: string, timeout?: number, unreadOnly?: boolean, options?: any): Promise<EmailPreview[]>;
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    waitForNthEmail(inboxId?: string, index?: number, timeout?: number, unreadOnly?: boolean, options?: any): Promise<Email>;
}
/**
 * WebhookControllerApi - fetch parameter creator
 * @export
 */
export declare const WebhookControllerApiFetchParamCreator: (configuration?: Configuration) => {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, webhookOptions: CreateWebhookOptions, options?: any): FetchArgs;
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): FetchArgs;
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWebhooks(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): FetchArgs;
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): FetchArgs;
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendTestData(webhookId: string, options?: any): FetchArgs;
};
/**
 * WebhookControllerApi - functional programming interface
 * @export
 */
export declare const WebhookControllerApiFp: (configuration?: Configuration) => {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, webhookOptions: CreateWebhookOptions, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto>;
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response>;
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWebhooks(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageWebhookProjection>;
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto>;
    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto[]>;
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendTestData(webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookTestResult>;
};
/**
 * WebhookControllerApi - factory interface
 * @export
 */
export declare const WebhookControllerApiFactory: (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) => {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(inboxId: string, webhookOptions: CreateWebhookOptions, options?: any): Promise<WebhookDto>;
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): Promise<Response>;
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllWebhooks(page?: number, size?: number, sort?: "ASC" | "DESC", options?: any): Promise<PageWebhookProjection>;
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: string, options?: any): Promise<WebhookDto>;
    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(inboxId: string, options?: any): Promise<WebhookDto[]>;
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendTestData(webhookId: string, options?: any): Promise<WebhookTestResult>;
};
/**
 * WebhookControllerApi - object-oriented interface
 * @export
 * @class WebhookControllerApi
 * @extends {BaseAPI}
 */
export declare class WebhookControllerApi extends BaseAPI {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    createWebhook(inboxId: string, webhookOptions: CreateWebhookOptions, options?: any): Promise<WebhookDto>;
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    deleteWebhook(inboxId: string, webhookId: string, options?: any): Promise<Response>;
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    getAllWebhooks(page?: number, size?: number, sort?: 'ASC' | 'DESC', options?: any): Promise<PageWebhookProjection>;
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    getWebhook(webhookId: string, options?: any): Promise<WebhookDto>;
    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    getWebhooks(inboxId: string, options?: any): Promise<WebhookDto[]>;
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    sendTestData(webhookId: string, options?: any): Promise<WebhookTestResult>;
}
